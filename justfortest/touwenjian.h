#include <map>
#include <stack>
typedef map<char, int> Index;

class CFG{		//文法类
private:
	char terminals[50] = {'k', 'i', 'n', '+', '-', '=', '*', '/', '(', ')', '{', '}'};		//终结符
	int terninals_count = 12;	
	char nonterminals[50] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};		//非终结符
	int nonterminals_count = 8;
	string productions[100] = {"AB(){C}", "B!", "BkiD", "D!", 
	"D,iD", "D;", "C!", "CE;C", "Ei=F", "EB", "FF+G", "FF-G", "FG", "GG*H", "GG/H", "GH", "H(F)", "Hi", "Hn"};	//产生式
	int productions_count = 19;		
	string first[50];	//first集合
	string follow[50];	//follow集合
	Index terminals_index;	//终结符的索引
	Index nonterminals_index;	//非终极符的索引
	Index nonterminals_index_in_productions;	//产生式的索引

public:
	CFG(char* T, int T_count, char* N, int N_count, string* P, int P_count){
		//待实现，初始化CFG，并进行消左递归和左因子操作（消左递归和左因子也可以单独写一个函数）
	}

	CFG(){
		//手动初始化一些私有属性
		for(int i = 0; i < terninals_count; i++){
			terminals_index[terminals[i]] = i;
		}
		for(int i = 0; i < nonterminals_count; i++){
			nonterminals_index[nonterminals[i]] = i;
		}
		nonterminals_index_in_productions[nonterminals[0]] = 0;
		for(int i = 1, j = 0; i < productions_count; i++){
			if(productions[i][0] != productions[i - 1][0]){
				nonterminals_index_in_productions[nonterminals[j]] = i;
				j++;
			}
		}

		//消除左递归和左因子
		eleminate_left_recursion();
		eleminate_left_divisor();
	}

	void eleminate_left_recursion(){
		for(int i = 0; i < productions_count; i++){
			if(productions)
		}
	}

	void eleminate_left_divisor(){

	}

	string calculate_first(string s1){
		string ret;
		//待实现（计算first集合）
		return ret;
	}

	string calculate_follow(string s1){
		string ret;
		//待实现（计算follow集合）
		return ret;
	}
};

class Predicting_Analysis_Table{		//预测分析表类
private:
	Index terminals_index;	//终结符的索引
	Index nonterminals_index;	//非终结符的索引
	string predicting_analysis_table[50][50];	//预测分析表

public:
	Predicting_Analysis_Table(CFG cfg){
		//待实现，构造预测分析表
	}
};

class Symbol_Table_Item{		//符号表中的一条记录
private:
	string internal_identification;		//记号的内部表示
	string external_identification;		//记号的外部表示
	char grammar_identification;	//记号在文法中的表示
	int token_index;	//记号的类型编号
	int address;	//如果是标识符，则存储记号的地址
	int size;	//如果是标识符，则存储在内存中所占的大小
};

class Symbol_Table_Manager{		//符号表管理器类
private:
	Symbol_Table_Item symbol_table[1000];	//符号表
	int Symbol_Table_Item_Count;
};

class Analysis_Tree_Node{		//该类代表分析树中的结点，其指针类型代表一颗分析树
private:
	int index_in_symbol_table;	//元素在符号表中的下标
	Analysis_Tree_Node *firstchild, *nextsibling;		//树的二叉链表表示法
};

typedef Analysis_Tree_Node *Analysis_Tree;		//分析树

class LL1_Driver{		//驱动器类，实现LL(1)驱动器算法
private:
	stack<char> symbol_stack;	//符号栈
	stack<int> index_in_symbol_table_stack	//存储符号栈中的元素在符号表中对应的下标 

public:
	Analysis_Tree run_driver(Symbol_Table_Manager stm, Predicting_Analysis_Table pat){
		Analysis_Tree ret = new Analysis_Tree_Node();
		//待实现(驱动器算法)
		return ret;
	}
};